因学校课设而初识业务，找了个在网上卖课的项目了解结构。（说实话代码挺烂的，一看应该是其他语言转的go）

# gin框架

## 装饰者模式

装饰者模式允许用户在不修改对象本身的情况下，通过添加额外的职责来扩展对象的功能。在Gin框架中，`Use`方法可以为处理链增加多个中间件，这些中间件可以对请求进行预处理、鉴权、跨域处理等，最后进行原始业务逻辑的处理。其中每个中间件可以访问请求和响应对象，并且可以决定是否继续执行链中的下一个中间件。通过链式调用，

通过这种方式，`Use`函数允许开发者动态地添加功能，而不需要改变原有业务逻辑代码，这正是装饰者模式的核心思想。

## 与前端交互

从`ShouldBind()`看通过http头中的Content-Type字段得到反序列化格式（JSON、XML、ProtoBuf、MsgPack、YAML、TOML、FormMultipart、Form）（像query、uri方式的传参还是得跟前端做好沟通），拿到前端传来的数据，做完全部的业务处理后，`c.Render`将数据序列化后发回前端



# Gorm框架

将sql语句接口化，通过调用函数传参就可以代替通过格式化字符串来拼接sql语句,同时通过反射将数据直接传给了结构体，而不用做很多无聊繁杂的编码（指给结构体的字段一个一个赋值），它还通过参数化查询来防止 SQL 注入，让用户可以专注于业务逻辑的处理。接口化后还可以无缝替换为其他的数据库管理系统，不用更改为别的语法。

## 表设计

以订单系统举例，将一个订单系统分成多个表来存储不同的信息是数据库设计中的一种常见做法，称为**数据库范式**，其目的是为了减少数据冗余、提高数据一致性和数据库的性能。下面是分为三个表的具体原因：

1. **分离关注点**：

   - **订单主表**：专门存储订单的核心信息，如订单号、用户ID、支付信息、订单状态等。
   - **订单项表**：存储订单中每个商品的详细信息，如商品ID、商品名称、商品图片、价格和数量等。这是因为一个订单可能包含多个商品，如果把所有商品信息都存储在订单主表中，会造成字段冗余和数据查询复杂化。
   - **订单地址表**：存储收货地址信息。收货地址信息可能包括多个字段，直接存储在订单主表中会使表变得非常宽，影响查询性能。

2. **数据冗余和一致性**：

   如果在同一个表中存储所有信息，数据冗余和不一致的问题会变得更严重。例如，一个订单中有多个商品时，订单表会有多个记录，每条记录都包含重复的订单信息和地址信息。分表设计可以将需要冗余的数据（如商品信息、收货地址信息）分别存储在各自的表中，以确保即使商品信息或地址信息发生更改，订单记录中的信息仍然保持原样（快照），保证数据的一致性。

3. **性能优化**：

   常见的查询操作可以更高效地在特定表上执行，例如：查询订单的核心信息时，只需访问订单主表。查询订单中的商品信息时，只需访问订单项表。查询订单的收货地址时，只需访问订单地址表。

4. **维护和扩展性**：

   - 将不同的信息存储在不同的表中，使得表的结构更加简洁、维护更加容易。比如，如果需要修改商品信息的结构，只需修改订单项表，不会影响到订单主表或订单地址表。
   - 未来如果需要添加新的信息（例如物流信息、发票信息等），可以通过增加新的关联表来实现，而不会对现有表的结构造成太大影响。

## 用标记来代替删除数据

在实际生产环境中，当需要删除或更改数据库中的某个对象时，通常会选择**软删除**，即将原对象标记为不可用（例如设置一个 `is_deleted` 字段），而不是直接修改或删除原对象。这种方法有几个重要的好处：

### 从业务应用上

#### 1. 历史记录保留

**历史记录**：标记为不可用的方法保留了所有历史数据，可以追踪记录的变化。对业务来说，了解过去的数据变动历史非常重要，比如订单状态的变更、商品价格的调整等。在许多行业中，**审计**和合规要求需要保留所有操作的记录。

#### 2. 操作简单和减少风险

直接修改或删除数据操作风险较高，特别是在复杂的业务逻辑中，操作可能影响多个相关表和数据，导致**数据不一致**问题。例如，在删除操作进行时，可能有其他相关的记录依赖于这条记录。如果删除了这条记录，而这些依赖关系没有及时处理，系统可能会出现数据不一致的问题。标记为不可用则相对安全，不容易引发严重错误。（软删除和硬删除都要做好对应的处理）

而且通过软删除，允许在需要时简单的恢复数据、及时查看历史记录，而直接删除或修改导致丢失数据，从备份中重新录入数据、日志恢复（能力有限）都需要额外消耗。

### 从内部技术上（仅提供不同的可能，并不确定哪种性能更好，更多还是业务上的考量）

#### 1. 避免长时间锁定

**行锁和表锁**：在高并发环境中，直接删除记录（物理删除）可能导致数据库在执行删除操作时锁定相关行或表，尤其是在使用事务的情况下，这种锁定会导致其他事务必须等待，降低系统整体性能。逻辑删除只需更新一个字段，锁定时间短，冲突小。

#### 2. 维持数据页面的稳定性

物理删除可能需要数据库**重建索引**，特别是涉及到主键或唯一索引时，会导致**数据页的分裂和合并**，造成额外的磁盘复制，从而增加数据库的维护开销。逻辑删除不会改变数据页的结构，只是简单地标记记录。但会导致**数据冗余**，也会降低性能吧。

#### 3. 降低I/O操作（耗时最长）

物理删除会导致大量的磁盘I/O操作，特别是当删除大量记录时。这会显著影响数据库的性能。逻辑删除只是一次更新操作，磁盘I/O开销非常小。



# session与JWT

它们是用来在用户单击进入不同页面时以及登陆网站或应用程序后进行**身份验证**的技术。

如果没有这两者，那你可能需要在每个页面切换时都需要进行登录了。因为 HTTP 是一个无状态的协议。这也就意味着当你访问某个网页，然后单击同一站点上的另一个页面时，服务器的`内存中`将不会记住你之前的操作。

**JWT 和 Session Cookies 就是用来处理在不同页面之间切换，保存用户登录信息的机制**。

## **Session：**

是用户登录后，服务器来保存用户的状态，返回客户端一个唯一的ID，缺点是需要占用服务端内存，如果要支持分布式、微服务的话，还需要把session放到redis集群里实现跨服务器共享。

## **JWT是有三部分组成的：**

#### Header：
包括签名的算法，默认是 HMAC SHA256（写成 HS256），和这个令牌的类型，JWT 令牌统一写为JWT。

```json
{
2  "alg": "HS256",
3  "typ": "JWT"
4}
```

#### Payload：

Payload部分也是一个Json对象，用来存放实际需要传输的数据，例如：签发人，用户信息，过期时间等（不能放私有的敏感数据）

```json
{
2  "name": "xiaoMing",
3  "age": 14
4}
```

#### Signature：

Signature部分是对前面的两部分的数据进行签名，防止数据篡改。

首先需要定义一个秘钥，这个秘钥只有服务器才知道，不能泄露给用户，然后使用Header中指定的签名算法（以秘钥为种子），算出签名以后将Header、Payload、Signature三部分拼成一个字符串，每个部分用`.`分割开来，就可以返给用户了。用户再次发送时，接收方可以使用相同的密钥来验证签名是否与消息匹配。

```
Signature=HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret)
```

使用 JWT 主要用来下面两点：

- `认证(Authorization)`：这是使用 JWT 最常见的一种情况，一旦用户登录，后面每个请求都会包含 JWT，从而允许用户访问该令牌所允许的路由、服务和资源。`单点登录`是当今广泛使用 JWT 的一项功能，因为它的开销很小。
- `信息交换(Information Exchange)`：JWT 是能够安全传输信息的一种方式。通过使用公钥/私钥对 JWT 进行签名认证。此外，由于签名是使用 `head` 和 `payload` 计算的，因此你还可以验证内容是否遭到篡改。

关于**安全性**，指的是不会造成密码的泄露，如果sessionID和token泄露的话，也还是能登陆的，所以要有**过期时间**。

关于跨域请求那块，没太理解，大概是默认行为不一样。如果在http header中配置好的话应该都是可以跨域的。